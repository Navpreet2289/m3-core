**********************************
Подробное описание серверной части
**********************************

В данный момент на стороне сервера реализованы механизмы работы с сообщениями и с задачами.
Сообщения - это просто некое (любое) уведомление от сервера к браузеру. Задача - очередь
сообщений, которые по мере выполнения задачи посылается от сервера к браузеру.


Сообщения
=========

Отправить сообщение на сервер очень просто, например вот так::

    >>> user = request.user
    >>> message = Message(from_user=user, send_datetime=datetime.now(), subject='Test', text='Loong text', to_users=user)
    >>> message.send()

Для использования с celery возможен вот такой вариант::

    >>> from celery import subtask
    >>> message = Message(from_user=user, send_datetime=datetime.now(), subject='Test', text='Loong text', to_users=user)
    >>> generate_report.apply_async(*args, **kwargs, link=subtask(message.send))

Задачи
======

Для видимости асинхронного выполнения задач реализованы следующие механизмы. Класс *Progress*
*livemessages/src/livemessages/tasks/progress.py* предназначенный для работы долгих вычислений в цикле.

Например можно написать вот такой код::

    for i in Progress(range(100), parts=10, callback=_callback):
        print i

Это значит через каждые 10% прохода будет вызываться функция *_callback*. *range(100)* - в данный момент поддерживаются объекты,
джанговские QuerySet'ы и списки с кортежами. (По идее ничего не мешает организовать поддержку объектов, выдающих количество элементов при использовании функции *len*)

.. note::
    Внимание, внутри 1 раз будет генерироваться SQL конструкция SELECT COUNT * FROM ... для получения количества элементов) .

Задачи можно использовать примерно так::

    @progress(u'Перебор произвольной модели')
    def test_model(request, model, task=None):
        import time

        all = model.objects.all()
        for i in Progress(all, parts=5, task=task):
            time.sleep(0.03)

В декораторе *progress* задается название задачи, текст начала и текст окончания обработки. В нем же
создается экземпляр задачи *Task* и передается функции как именованный параметр *task*. Это нужно для того, чтобы
в модели так же сохранять состояние задачи. Вызов такой функции сгенерирует в декараторе два сообщения начала и
окончания задачи, так же будет через каждые 20% прохода по циклу генерировать сообщение браузере
и передовать в него состояние задачи.


Есть возможность использовать данную возможность без декоратора, в таком случае нужно будет позаботиться
о создании объекта *Task* вручную::

    task = Task(from_user=request.user, task_name=u'Долгая задача')
    task.begin(state=u'Начало выполнения задачи')

    all = SimpleModel.objects.all()
    for i in Progress(all, parts=5, task=task):
        time.sleep(0.03)

    task.end(state=u'Окончание задачи')