.. _m3_replica:

Репликация данных (m3_replica)
==============================

Общие сведения
--------------

Приложение ``m3.contrib.m3_replica`` содержит функционал, позволяющий разрабатывать
подсистемы импорта/эспорта данных в прикладных проектах.


Любой процесс обмена данными между информационными системами сводится к
следующим операциям:

* Получение данных из некоторого источника (файл, внешняя СУБД, web-сервис, 
  сторонняя информационная система и проч.). Получение данных может происходить
  как за одну операцию чтения (как в случае с web-сервисом), так и за многокраное
  обращение к операции чтения (например, выборка записей из курсора к внешней СУБД);
* Обработка полученной порции данных с целью приведения их к виду, в котором они
  могут быть переданы получателю.
* Сохранение информации в получателе данных. Это чаще внутренняя СУБД 
  информационной системы. Иногда, web-сервис, отдающий информацию вовне системы. 

Реализация приложения ``m3_replica`` предусматривает следующие базовые классы, 
которые выполняют указанные выше операции: ``BaseDataSource``, ``BaseDataExchange``
и ``BaseDataTarget``

Источники данных
----------------

Источником данных является класс, унаследованный от базового класса 
``m3_replica.engine.BaseDataSource``, который определяет 
интерфейс объекта, управляющего доставкой данных в систему.

.. autoclass:: m3.contrib.m3_replica.engine.BaseDataSource
  :members:
  
Методы ``open_session()`` и ``close_session`` вызываются, соответственно, 
в начале и в завершении выполнения операции, поэтому в них необходимо 
реализовать открытие и освобождение необходимых ресурсов.

Основная задача метода ``read()`` - это возврат очередной порции данных из
источника данных. Данные возвращаются максимально в том виде, 
который определяется источником данных. Желательно, при реализации формы
возврата данных не заниматься глубоким переформирматированием порции данных
в целях максимальной реюзабельности данного класса.

Пример конкретной реализации класса-источника данных::

    class DjangoSQLDataSource(BaseDataSource):
        '''
        Описывает источник данных в виде 
        '''
        def __init__(self, db_name, query):
            '''
            Инициализирует состояние источника данных.
            
            @param db_name: наименование базы данных
            '''
            super(DjangoSQLDataSource, self).__init__()
            
            self.db_name = db_name
            self.query = query
            
            self._cursor = None
            self._fetching = False
            
        def open_session(self):
            '''
            Открывает соединение к базе данных и получает курсор 
            '''
            self._fetching = False
            if self._cursor:
                self._cursor.close()
                
            self._cursor = connections[self.db_name].cursor()
            
        def close_session(self):
            '''
            Закрывает соединение с базой данных
            '''
            self._fetching = False
            if self._cursor:
                self._cursor.close()
                self._cursor = None
                
        def read(self):
            '''
            Возвращает генератор, который фетчит записи из курсора с указанным 
            запросом.
            '''
            if not self._fetching:
                # выполняем запрос в базу данных
                self._cursor.execute(self.query)
                
            for row in self._cursor:
                yield row 



Приемники данных
----------------

Класс-приемник данных реализует инфраструктуру по сохранению преобразованных 
после получения из источника данных. Такой класс должен быть унаследован от
класса ``m3_replica.engine.BaseDataTarget``.

.. autoclass:: m3.contrib.m3_replica.engine.BaseDataTarget
  :members:
  
Методы ``open_session`` и ``close_session`` вызываются, соответственно, 
в начале и в завершении выполнения операции переноса данных в целом, 
поэтому в них необходимо реализовать открытие и освобождение необходимых ресурсов.

Метод ``write`` выполняет запись переданных объектов в приемних данных.

Пример реализации класса-приемника данных::

    class ModelDataTarget(BaseDataTarget):
        '''
        Получатель данных, который занимается сохранением информации
        в модели приложения.
        
        Принимает к сохренению следующие типы объектов:
        * просто модель;
        * список моделей;
        * список моделей, упакованный в объект типа ReplicatedObjectsPackage
        '''    
        def __init__(self):
            super(ModelDataTarget, self).__init__()
            
        def write(self, objects):
            '''
            Выполняет сохранение переданных(-ой) моделей(-и) в базу данных.
            
            @param objects: список (list) либо экземпляр класса, реализующего
                            метод save()
            
            Особенности:
            * управление транзакциями происходит на уровне управляющего 
              DataExchange;
            '''
            
            if isinstance(objects, list):
                for obj in objects:
                    obj.save()
            elif isinstance(objects, ReplicatedObjectsPackage):
                for obj in objects.get_objects():
                    obj.save()
            else:
                # тупо пытаемся вызвать метод save()
                # если такого метода нет, то извиняйте ребята,
                # нечего всякую хрень сюда совать
                objects.save()
                
            return objects