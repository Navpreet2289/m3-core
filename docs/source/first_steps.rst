.. _first_steps::

Первые шаги с M3
=================

Для работы с M3 обязательны базовые знания `Python <http://docs.python.org>`_.


Решаемые задачи
---------------

Построение гибких масштабируемых платформонезависимых корпоративных приложений с Rich Client интерфейсом.

Архитектура платформы m3
------------------------

В основе платформы m3 лежит Django фреймворк. Описание, которого можно найти в главе :doc:`django/django_main`
Отличительно особенностью Django является архитектура проекта. Каждый проект состоит из независимых или слабозависимых приложений.
Каждое приложение реализует паттерн MTV (Model – Template – View).
``Model`` – модель из классического MVC.
``Template`` – Django шаблон, аналог представления View из MVC.
``View`` – controller из классического MVC.
Каждый проект, в основе которого лежит платформа m3 состоит из модулей. Каждый модуль является отдельным приложением, которое существует само по себе и может быть встроено в другое приложение или вынесено в другой проект.
Архитектура каждого приложения очень похожа на архитектуру приложения в Django. Но имеется серьезные переработки некоторых компонент MTV.
В роли модели выступает обычная Django-модель.
В роли контроллера (view из MTV) выступает ``Action``. ``Action`` является внутренним классом m3. Он пришёл на смену Django-view. Дело в том, что подход, используемый в Django прост и вполне подходит для home-page приложений, однако масштабные корпоративные приложения выдвигают новые требования:

    1.	Отсутствие вшитых в программу адресов (URL)
    2.	Изменение адресов на ходу
    3.	Перехват выполнения перед view и после view.
    4.	Автоматическое извлечение и контроль входных параметров view.
    5.	Гибкое встраивание нового функционала
Для решения этих задач механизм ``URL Dispatcher``, используемый в Django был заменен на собственный механизм. Django-view используются только как точки входа в приложение. Т.е. одно приложение – одна view, в которую приходят все запросы, адресованные данному приложению. Далее будем называть её view-controller. На смену остальным view пришли классы ``Action``, ``ActionPack`` и ``ActionController``, которые образуют механизм, отвечающий требованиям крупного корпоративного проекта.
В  качестве представления выступают controls из подсистемы графических компонент m3. Controls представляют собой в большей степени реализацию ExtJS control, а так же имеются и свои наработки.

Как использовать M3 в своем проекте? Создание проекта на M3
-----------------------------------------------------------

Для того, чтобы использовать M3 в своем проекте, необходимо скопировать исходные коды платформы с репозитария и
прописать пути в python path.

Также можно использовать проек-болванку, где все уже готово для создания приложений. О том как создать проект на основе
болванки m3_blank можно прочитать в главе :doc:`project_blank`.

Как создать приложение, которое опирается на платформу M3?
-----------------------------------------------------------

Теперь можно приступить к созданию приложения. Об этом можно прочитать в главе :doc:`create_app`

Также доступен пример создания простого приложения :ref:`dict_example`.


Надо вынести отсюда. Механизм обработки запроса с высоты птичьего полета
---------------------------------------------------

При старте приложения построенного на базе m3 происходит инициализация специфичных возможностей m3. Для этого в каждом приложении должен быть
файл ``app_meta.py``, который содержит в себе:

* Определение контроллера приложения и регистрацию экшенов. Смотри главу :doc:`actions_and_packs`
* Регистрацию адресов приложения без ``urls.py``
* Регистрацию ярлыков рабочего стола и меню
* Регистрацию точек расширений

Когда приходит запрос на определенный URL, происходит поиск view-controller, которая ответственна за его обработку, в файле привязок.
Узнать файл привязки можно из значения параметра ``ROOT_URLCONF``, в файле ``settings.py``.
Если URL, не указан в файле привязок, то он должен быть зарегистрирован в методе ``register_urlpatterns``, который расположен в файле ``app_meta.py`` приложения. Но для того, чтобы
метод ``register_urlpatterns`` вызывался необходимо в файл привязок добавить строку: ::
    urlpatterns += urls.get_app_urlpatterns()
После этого в найденном view-controller вызывается метод ``process_request``, привязанного к нему контроллера.
В данном методе выполняется формирования стэка pack-ов и поиск action-ов, соответствующего данному URL. Если поиск закончился неудачей генерируется ошибка с кодом 404.
В случае, если action найден, запрос проходит через все pack-и из построенного стэка и сам action. В каждом pack и action он проходит через
три метода:

    * ``pre_run``
    * ``run`` - наиболее часто пеереопределяется разработчиком в action, для формирования ответа.
    * ``post_run``

После отдается ответ клиенту. Подробнее о типах ответа можно узнать из главы :doc:`actions_results`.
