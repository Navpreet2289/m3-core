# coding: utf-8
'''
Created on 12.04.2011

@author: prefer
'''
import ast
import os
import json
import codegen
import shutil # Для копирования файлов

# Для тестов 
import pprint

from advanced_ast import StringSpaces

class Parser(object):
    '''
    Класс, отвечающий за преобразование данных
    '''
    
    # Имя функция, которая будет сгенерирована
    GENERATED_FUNC = 'initialize'
    
    # Название папки для бакапа
    BACKUP_DIR_NAME = '.form-backup'
    
    # Сколько бакупных файлов хранить
    BACKUP_FILES_MAXIMUM = 10
    
    # Для юникода
    UNICODE_STR = '#coding: utf-8\n\n'
    
    # Док стринга для функции автогенерации
    GENERATED_FUNC_DOCSTRING = '''AUTOGENERATED'''
    
    
    def __init__(self, path, class_name):
        '''
        @param path: Путь до py файла
        @param class_name: Имя класса для генерации
        '''
        self.path = path
        self.class_name = class_name
        
        # Содержаться вложенные объекты для последующей генерации
        # Пример:
        # {'self':[{'simple_panel':[...]},{'simple_form':[...]}]}
        self.dict_instances = {}
        
        
        self.dict_attrs = {}
        
        self.list_ignore_nested = []
        
        # Старый исходный код модуля
        self.old_source_code = ''
        
        # Базовый класс для окон (Если нет в маппинге)
        self.base_class = 'BaseExtWindow'
        
    def to_designer(self):
        '''
        Отвечает за преобразования py-кода в json, понятный m3-дизайнеру.
        Возвращает json объект в виде строки.
        '''
        source_code = open(self.path).read()
        node_module = ast.parse(source_code)
        class_node, func_node = self._get_func_initialize(node_module, self.class_name)
        
        self.base_class = self._get_base_class(class_node)
        
        
        assert func_node, 'Function name "%s" is not define in class "%s"' % \
                        (Parser.GENERATED_FUNC, self.class_name,)
        
        self.nested_cmp = {}
        self.config_cmp = {}
        for node in func_node.body:
            if isinstance(node, ast.Assign):
                # Составление структуры конфигов и типов компонентов
                
                # Игнорирование значений, которые просто прописываются в объект
                # self.panel_1 = panel_1
                if  isinstance(node.value, ast.Name) and node.value.id in self.config_cmp:
                    continue
                
                parent, attr, value = self._get_config_component(node)
                self.config_cmp.setdefault(parent, {})[attr] = value
                
            elif isinstance(node, ast.Expr) and isinstance(node.value, ast.Call):
                # Составление структуры вложенных компонентов
                parent, child = self._get_nested_component(node.value)
                self.nested_cmp.setdefault(parent, []).append(child)
                        
        return self._get_json()        

    def _get_base_class(self, class_node):
        '''
        Получает базовый класс
        '''
        return class_node.bases[0].id

    def _get_json(self, key='self', a_property_dict=None):
        '''
        Преобразует линейную структуру вида:
            {'panel1': ['field1'], 'self': ['panel1', 'panel2']}
        в иерархическую структуру вида:
            {'self':[{'panel1': ['field1']}, {'panel2': []}]}  
            
        И попутно преобразует py-объекты в объекты дизайнера
        В конечном итоге получается словарь, понятный дизайнеру  
        '''
        res_dict = a_property_dict if isinstance(a_property_dict, dict) else {}                
               
        tmp_list = []
        if self.nested_cmp and self.nested_cmp.get(key):
            for item in self.nested_cmp[key]:

                property_dict = {}      
                if self.nested_cmp.get(item):
                    res_dict.setdefault('items', []).append(property_dict)
                    self._get_json(item, property_dict)                                               
                else:
                    property_dict.update( self._get_json_config(item ) )    

                tmp_list.append(property_dict)
        
        if self.config_cmp:
            res_dict.update(self._get_json_config(key))    
            res_dict.update({'items': tmp_list})
        else:
            res_dict = {'id':'self'}
        return res_dict
    
    def _get_json_config(self, key):
        '''
        Возвращает конфигурацию компонента в качестве словаря
        '''
        properties, py_name = self._get_properties(key)
        properties['type'] = py_name
        properties['id'] = key
        return properties

    def _get_properties(self, key):
        '''
        Возвращает кортеж: свойства контрола, имя контрола в натации дизайнера
        (extjs)
        '''
        conf = self.config_cmp[key].copy()
        py_name = conf.pop('py_name') if conf.get('py_name') else self.base_class
        
        extjs_name = self._get_extjs_class(py_name)
        assert extjs_name, 'Mapping for class "%s" is not define' % py_name
        
        properties = dict(id= key) 
        for k, v in conf.items():            
            extjs_attr = self._get_json_attr(k, extjs_name)            
            assert extjs_attr, 'Mapping object "%s" for "%s" is not define' % (k, extjs_name,)
            properties[extjs_attr] = v
            
        return properties, extjs_name
    
    def _get_extjs_class(self, py_name):
        '''
        Получает из маппинга наименование extjs класса 
        '''
        for item in self._get_mapping():
            k, v = item['class'].items()[0] # Одно значение
            if v == py_name:
                return str(k)
                    
    def _get_json_attr(self, name, extjs_class_name):
        '''
        Получает из маппинга свойство по наименованию extjs контрола
        '''
        conf = self._gen_config(extjs_class_name)

        for k, v in conf.items():
            if v == name:
                return str(k)
        
    def _gen_config(self, type_obj):  
        '''
        Получение конфигурации свойств из маппинга по типу объекта
           @param type_obj: Тип объекта (window, panel, etc.)
        '''         
        for item in self._get_mapping():
            if item['class'].has_key(type_obj):
                return item['config']        
        
    def _get_nested_component(self, node_value):
        '''
        Распарсивается структура вида:
        self._items.append(panel)
        
        node_value.func.value.value.id - доступ к self
        node_value.args[0].elts[0].id - доступ к panel
        '''
        assert isinstance(node_value, ast.Call)
        
        return node_value.func.value.value.id, node_value.args[0].id

    def _get_value(self, node):
        '''
        Получает значение исходя из типа узла
        '''
        return ast.literal_eval(node)

    def _get_config_component(self, node):
        '''
        Разбирает конструкцию вида:
        
        self.width = 100
        
        parent - self
        attr - width
        value - 100        
        '''
        assert isinstance(node, ast.Assign)
        if isinstance(node.value, ast.Call):
            # Создание экземпляра            
            # instanse, attr, class name
            return node.targets[0].id, 'py_name', node.value.func.id
        else:            
            # Распарсивание свойства
            # parent, attr, value
            return node.targets[0].value.id, node.targets[0].attr, self._get_value(node.value)        
    
    def from_designer(self, json_dict):
        '''
        Отвечает за преобразование json-a формы из m3-дизайнеру в py-код.
        '''

        # Преобразование модуля в AST дерево
        self.old_source_code = open(self.path).read()
        module_node = ast.parse(self.old_source_code)
        
        # Нахождение нужной функции GENERATED_FUNC
        class_node, func_node = self._get_func_initialize(module_node, self.class_name)
        
        Node.mapping = self._get_mapping()
        nodes = Node(json_dict).get_nodes()

        self._set_class_name(class_node, json_dict['type'])
        
        # Старая док строка не должна потеряться
        if func_node and isinstance(func_node.body, list) and len(func_node.body) > 0 \
            and isinstance(func_node.body[0], ast.Expr):            
            nodes.insert(0, func_node.body[0])
            
        # Замена старого содержимого на новое сгенерированное 
        func_node.body = nodes                       

        # Бакап файла на всякий пожарный случай и cохранение нового файла
        source_code = codegen.to_source(module_node)        
        self._write_to_file(source_code)
        
    def from_designer_preview(self, json_dict):
        '''
        Преобразовывает js в py код и возвращает его в виде строки
        '''

        Node.mapping = self._get_mapping()        
        nodes = Node(json_dict).get_nodes()

        list_source_code = map(codegen.to_source, nodes)
        return '\n'.join(list_source_code)

 
    def _set_class_name(self, node, extjs_type):
        '''
        Устанавливает соответсвующее имя класса наследника
        '''
        for item in self._get_mapping():
            k, v = item['class'].items()[0]
            if k ==  extjs_type:
                node.bases = [ast.Name( str(v), ast.Load())] 
                break
        
    def _write_to_file(self, source_code):
        '''
        Запись в файл сгенерированного кода
        '''
        # 1. Создание директории, если нет
        # 2. Рекурсивное переименование всех имеющихся бакупных файлов в
        # файлы вида: .old.1, old.2, old.3
        # 3. Сохранение старого исходного кода с расширением old
        # 4. Перезапись файла новым содержимым
        
        dir = os.path.dirname(self.path)
        dir_backup = os.path.join(dir, Parser.BACKUP_DIR_NAME)
        if not os.path.isdir(dir_backup):
            os.mkdir(dir_backup)
        else:
            # Могут быть бакупные файлы, обход по времени последнего изменения
            for file_name in sorted(os.listdir(dir_backup), 
                                key=lambda f: os.stat(  os.path.join(dir_backup, f) ).st_mtime):
                file_path = os.path.join(dir_backup, file_name)
                                                 
                i = file_path.split('.')[-1]
                try:
                    int(i)
                except ValueError:
                    os.rename(file_path, '%s.%d' % (file_path, 0) )
                else:
                    if int(i)+1 > Parser.BACKUP_FILES_MAXIMUM:
                        os.remove(file_path) 
                    else:                       
                        file_name_parts = file_path.split('.')
                        without_end = file_name_parts[:-1]
                        os.rename(file_path, '%s.%d' % ('.'.join(without_end), int(i)+1) )
                    
        new_path = os.path.join(dir_backup, os.path.basename(self.path))        
        shutil.copyfile(self.path, new_path + '.old')
        
        # Поддержка юникода            
        source_code = Parser.UNICODE_STR + source_code
        with open(self.path, 'w') as f:
            f.write(source_code)

    def _get_mapping(self):
        '''
        Получение объекта маппинга
        '''
        return mapping_list
        
    def _get_func_initialize(self, node_module, class_name):
        '''
        Поиск и возвращение функции GENERATED_FUNC 
        '''
        for node in node_module.body:        
            if isinstance(node, ast.ClassDef) and node.name == class_name:                
                for nested_node in node.body:    
                    if isinstance(nested_node, ast.FunctionDef) and nested_node.name == Parser.GENERATED_FUNC:
                        return node, nested_node
                else:
                    raise Exception('Autogenerated function "%s" is not defined in class "%s"' % 
                                    (Parser.GENERATED_FUNC, class_name)    )
                    
    @staticmethod
    def generate_class(class_name, class_base):
        '''
        Генерирует класс
        Конструкция вида:
        class <class_name>(<class_base>):
            def __init__(self, *args, **kwargs):
                super(<class_name>).__init__(*args, **kwargs)
                self.<Parser.GENERATED_FUNC>()
                
            def <Parser.GENERATED_FUNC>(self):
                self.layout = 'auto'
        
        Возвращает сгенерированный узел AST
        '''
        # Лисп ёпта
        node_constructor = ast.Expr(
                                ast.Call(
                                    ast.Attribute(
                                        ast.Call(
                                            ast.Name('super', 
                                                     ast.Load()
                                            ),
                                            [ast.Name( 
                                                str(class_name),
                                                ast.Load()
                                             ),
                                             ast.Name(
                                                 'self',
                                                 ast.Load()
                                             )],
                                            [],
                                            None,
                                            None
                                        )
                                         ,'__init__',
                                         ast.Load()
                                    )
                                    ,[]
                                    ,[]
                                    ,ast.Name(
                                        'args',
                                        ast.Load()
                                    ),
                                    ast.Name(
                                        'kwargs',
                                        ast.Load()
                                    )
                                )
                            )
        node_initial = ast.Expr(
                                ast.Call(
                                    ast.Attribute(
                                        ast.Name(
                                            'self',
                                            ast.Load()
                                        ),
                                        Parser.GENERATED_FUNC,
                                        ast.Load()                                              
                                    ),
                                    [],     
                                    [],
                                    None,
                                    None,
                                )
                            )
    
        contstructor_args = ast.arguments([ast.Name('self', ast.Load())], 
                                          'args', 
                                          'kwargs', 
                                          [])    
        
        constructor_func = ast.FunctionDef('__init__',
                                            contstructor_args, 
                                            [node_constructor, node_initial], 
                                            [])
    
    
        initial_args = ast.arguments([ast.Name('self', ast.Load())], 
                                     None, 
                                     None, 
                                     [])
            
        initial_nodes = [
#                         ast.Assign(
#                                [ast.Attribute(
#                                    ast.Name('self', ast.Load()), 
#                                    'title', 
#                                    ast.Load()
#                                 )], 
#                                 ast.Str(u'Окно')),
                          ast.Assign(
                                [ast.Attribute(
                                    ast.Name('self', ast.Load()), 
                                    'layout', 
                                    ast.Load()
                                  )],
                                 ast.Str('auto')) ]
        
        doc_str = ast.Expr(
                    ast.Str(Parser.GENERATED_FUNC_DOCSTRING)
                    )
        initialize_func = ast.FunctionDef(Parser.GENERATED_FUNC, 
                                          initial_args, 
                                          [doc_str,] + initial_nodes, 
                                          [])
            
        cl = ast.ClassDef(
                    str(class_name), 
                    [ast.Name(class_base, ast.Load())], 
                    [constructor_func, initialize_func,], 
                    [])
        
        return cl

class Node(object):
    
    mapping = None
    
    def __init__(self, data):        
        self.data = data                    
        

    @staticmethod
    def sort_items(items):
        key, item = items
        if isinstance(item, list):
            return 100
        elif isinstance(item, dict):
            return 10
        elif key == 'id':            
            return 0
        else:            
            return 1


    def get_nodes(self):
        '''
        '''
        nodes = []
        nodes_attr = []
        nodes_extends = [] 
        nodes_in_self = []
        
        self.walk(nodes, nodes_attr, 
                             nodes_extends, nodes_in_self)
        
        if nodes_attr:
            nodes_attr.insert(0, StringSpaces())
            nodes += nodes_attr
            
        if nodes_extends:
            nodes_extends.insert(0, StringSpaces())
            nodes += nodes_extends
            
        if nodes_in_self:
            nodes_in_self.insert(0, StringSpaces())
            nodes += nodes_in_self
        
        return nodes

    def walk(self, nodes, nodes_attr, nodes_extends, nodes_in_self):        
          
        for key, value in sorted(self.data.items(), key=Node.sort_items):
            if isinstance(value, list):
                extends_list = []
                for item in value:
                    if isinstance(item, dict) and item.has_key('id') and item.has_key('type'):
                        Node(item).walk(nodes, nodes_attr, nodes_extends, nodes_in_self)
                        extends_list.append(item['id'])
                    else:
                        ast_node = self._get_property(self.data['id'], key, value, self.data['type'])
                        nodes.append(ast_node)
                        break
                
                if extends_list:
                    ast_node = self._get_extends(self.data['id'], key, extends_list, self.data['type'])                    
                    nodes_extends.append(ast_node)
            elif isinstance(value, dict) and value.has_key('type') and value.has_key('id'):                
                Node(value).walk(nodes, nodes_attr, nodes_extends, nodes_in_self)             
                
                ast_node = self._get_attr(self.data['id'], key, value['id'], self.data['type'])
                
                nodes_attr.append(ast_node)
            else:
                if key == 'type' or value == 'self':
                    continue
                elif key == 'id' and value != 'self':                                                   
                    ast_node = self._get_instanse(self.data['type'], value)                                        
                    nodes.extend([StringSpaces(), ast_node, ])
                    
                    in_self_node = self._add_cmp_in_self(value)                    
                    nodes_in_self.append(in_self_node)                                
                else:                    
                    ast_node = self._get_property(self.data['id'], key, value, self.data['type'])
                    nodes.append(ast_node)                            
     
    def _add_cmp_in_self(self, field, parent_fields='self'):
        return ast.Assign(
                [ast.Attribute(
                        ast.Name(parent_fields, ast.Load()), 
                        str(field), 
                        ast.Load()
                    )], 
                ast.Name(field, ast.Load())
            )
    
    def _get_property(self, parent_field, extjs_attr, value, extjs_class):
        for item in self.mapping:
            if item['class'].has_key(extjs_class):
                
                assert item['config'].get(extjs_attr), 'Mapping is "%s" not found %s' % (extjs_class, extjs_attr)
                
                py_attr = item['config'][extjs_attr]
                return ast.Assign(
                    [ast.Attribute(
                        ast.Name(parent_field, ast.Load()), 
                        str(py_attr), 
                        ast.Load()
                    )], 
                    self._get_node_value(value)
                )
        else:
            raise ValueError("Mapping is undefined for class '%s'" % extjs_class) 
    
    def _get_instanse(self, extjs_class, value):
        for item in self.mapping:
            if item['class'].has_key(extjs_class):
                instanse_name = item['class'][ extjs_class ]
                                           
                assert value.find(" ") == -1, 'Variable "%s" can"t has whitespace' % value
                
                return ast.Assign([ast.Name( 
                                        value, 
                                        ast.Load()
                                  )], 
                                  ast.Call(
                                        ast.Name( 
                                            str(instanse_name) , 
                                            ast.Load()
                                        ), 
                                        [], 
                                        [], 
                                        None, 
                                        None)
                                  )
        else:
            raise ValueError("Mapping is undefined for class '%s'" % extjs_class) 
    
    def _get_attr(self, parent_field, extjs_attr, value, extjs_class):
        for item in self.mapping:
            if item['class'].has_key(extjs_class):
                
                assert item['config'].get(extjs_attr), 'Mapping is "%s" not found %s' % (extjs_class, extjs_attr)
                
                py_attr = item['config'][extjs_attr]
                return ast.Assign(
                    [ast.Attribute(
                        ast.Name(parent_field, ast.Load()), 
                        str(py_attr), 
                        ast.Load()
                    )], 
                    ast.Name(value, ast.Load())
                )
        else:
            raise ValueError("Mapping is undefined for class '%s'" % extjs_class) 
    

    def _get_extends(self, parent_field, extjs_name, list_cmp, extjs_class):        
        for item in self.mapping:
            if item['class'].has_key(extjs_class):
                
                assert item['config'].get(extjs_name), 'Mapping is "%s" not found %s' % (extjs_class, extjs_name)
                
                py_attr = item['config'][extjs_name]
                 
                ast_list = ast.List([ast.Name(item, ast.Load() ) for item in list_cmp], ast.Load())                                                                
                return ast.Expr( 
                            ast.Call(
                                ast.Attribute(
                                    ast.Attribute(
                                        ast.Name(
                                            parent_field,
                                            ast.Load()
                                        ),
                                        str(py_attr),
                                        ast.Load()       
                                    ),
                                    'extend',
                                    ast.Load()          
                                ),     
                                [ast_list,],
                                [],     
                                None,
                                None
                            )
                        )
        else:
            raise ValueError("Mapping is undefined for class '%s'" % extjs_class)            

    def _get_node_value(self, value):
        '''
        Генерация узла дерева для простых элементов
        Например для строки и числа, булевого типа
        '''        
        if value in ('False', 'True'):
            return ast.Name(value, ast.Load())
        elif isinstance(value, int):
            return ast.Num(value)
        elif isinstance(value, basestring):
            return ast.Str(value)
        elif isinstance(value, dict):
            return ast.Dict( [ self._get_node_value(str(k))  for k in value.keys()],
                             [ self._get_node_value(v) for v in value.values()] )
            
        elif isinstance(value, tuple):
            return ast.Tuple([self._get_node_value(item) for item in value], ast.Load())
               
        elif isinstance(value, list):
            return ast.List([self._get_node_value(item) for item in value], ast.Load())
        
        raise ValueError("Type '%s' value '%s' is not supported" % (type(value), value) )
             
                    
def update_with_inheritance(m_list, parent=None, config=None):
    '''
    Обновляет маппинг объектов с учетом наследование, то есть дозополняет
    свойствами объекты из унаследованных классов "parent"
    '''        
    
    for item in m_list:
        if parent and item.get('class').keys()[0] == parent:            
            config.update(item['config'])             
            break
        elif not parent and item.get('parent'):
            update_with_inheritance(m_list, item.get('parent'), item['config'])

# Для избавления от комментов делим файл на строки
raw_js = open(os.path.join(os.path.dirname(__file__), 'mapping.json'), 'r').readlines()

# Словарь сопоставлений контролов в дизайнере к контролам в питоне
mapping_list = json.loads('\n'.join(filter(lambda x: not '//' in x, raw_js)))

# Рекурсивное добавление свойств у классов наследников
update_with_inheritance(mapping_list)

#===============================================================================
def test_from_designer():
    '''
    С новым протоколом
    '''
    fake_data = {
        'name':'Ext window',
        'title':'Trololo',
        'layout':'fit',

        'type':'window',
        'id':'self',
        
        'items': [{
                'type': 'panel',
                'id': 'base_panel',
                
                'name':'Ext panel',
                'title':'Im panel ',
                'layout':'absolute',
                'items': [{
                    'type': 'gridPanel',
                    'id': 'grid_1',                      
                    'store': {
                        'id': 'store1'
                        ,'type':'arrayStore'
                    },
                      
                    'tbar':{
                            'id': 'tbar_1'
                            ,'type':'toolbar'
                            ,'items':[{
                                'type':'button'
                                ,'id':'button_1'
                                ,'text':u'Кнопка 1'
                            },{
                               'type':'button'
                                ,'id':'button_2'
                                ,'text':u'Кнопка 2'                            
                            }]
                    }
                    ,'columns': [{
                        'type': 'gridColumn',
                        'id': 'gridColumn_1',
                        'header': '2'  
                    },{
                       'type': 'gridColumn',
                        'id': 'gridColumn_2',
                        'header': '1'
                    }]     
                           
                }]
            }]
    }
        
    Node.mapping = mapping_list
    nodes = Node(fake_data).walk()

    list_nodes_str = map(codegen.to_source, nodes)
    print '\n'.join(list_nodes_str)         
    print '====== from_designer - ok ======'    
    
def test_to_designer():
    '''
    Для тестирования метода to_designer
    '''
    js = Parser('tests.py', 'TestOne').to_designer()        
    pprint.pprint( js ) 
    
    print 'Parser.to_designer - ok'
