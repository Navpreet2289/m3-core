# coding: utf-8

import ast
import os
import codegen

from parser import Parser
from m3.helpers.icons import Icons


EXCLUSION = ('pyc', 'orig',)
POSIBLE_EDIT_FILES = ('ui.py', 'forms.py')

        
def get_files(path):
    '''
    Возвращает список всех файлов в проекте
    @param path: Путь до директории с проектом 
    '''    
        
    li = []
         
    for ffile in sorted(os.listdir(path), \
            # Папки имеют приоритет над файлами
            key=lambda x: ' %s' % x if os.path.isdir(os.path.join(path, x)) else x):
            

        if ffile.split('.')[-1]  in EXCLUSION:
            continue
                
        path_file =  os.path.join(path, ffile)
      
        propertys_dict = dict(text=ffile) 
        if os.path.isdir(path_file):                                    
            propertys_dict['children'] = get_files(path_file)
            propertys_dict['leaf'] = False             
        else:            
            propertys_dict['path'] = path_file
                        
                             
            if ffile in POSIBLE_EDIT_FILES:
                propertys_dict['iconCls'] = Icons.PAGE_WHITE_CODE
                propertys_dict['leaf'] = False
            else:
                propertys_dict['iconCls'] = Icons.PAGE_WHITE_TEXT
                propertys_dict['attr'] = path_file
                propertys_dict['leaf'] = True
                 
        li.append(propertys_dict)
    return li


def get_classess(path):
    '''
    Возвращает набор классов в файле
    '''
    with open(path) as f:
        ast_module = ast.parse( f.read() )
        
        res = []
        for item in ast.walk( ast_module ):
            if isinstance(item, ast.ClassDef):
                d = {'text': item.name,
                     'leaf': True,
                     'iconCls':  Icons.PAGE_WHITE_C,
                     'class_name':  item.name,
                     'path': path}
                res.append(d)
            
        return res


def restores(data):
    '''
    Будет пытаться преобразить все символы в кодировку ascii, если это 
    невозможно - если присутсвует unicode символы, то оcтавляет их как есть
    '''
    for k, v in data.items():
        if isinstance(v, dict):
            restores(v)
        elif isinstance(v, list):
            map(restores, v)
        else:
            try:
                data[k] = str(v)
            except UnicodeEncodeError:
                pass # Итак останется в unicode
        
def _get_conf():
    '''
    Первоначальное заполнение функции initialize
    '''
    return [ast.Assign([ast.Attribute(ast.Name('self', 1), 'title', 1)], ast.Str(u'Окно')),
        ast.Assign([ast.Attribute(ast.Name('self', 1), 'layout', 1)], ast.Str('auto')) ]
        
def create_py_class(path, class_name, base_class = 'ExtWindow'):
    '''
    Создает класс с функцией автогенерации
    '''
    
    assert class_name.find(" ") == -1, 'Class name "%s" can"t has whitespace' % class_name
    try:
        str(class_name)
    except UnicodeEncodeError:
        raise Exception('Class name "%s" can"t has unicode symbols' % class_name)
    
    
    # Генерация содержимого
    # class <class_name>(self):
    #     'AUTOGENERATED'
    #     self.title = u'Окно' 
    args = ast.arguments([ast.Name('self', 1)], None, None, [])
        
    tuple_conf = _get_conf()
    doc_str = ast.Expr(ast.Str(Parser.GENERATED_FUNC_DOCSTRING))
    func = ast.FunctionDef(Parser.GENERATED_FUNC, args, [doc_str,] + tuple_conf, [])
    
    cl = ast.ClassDef(str(class_name), [ast.Name(base_class, 1)], [func,], [])
     
    # Чтение файла    
    f = open(path, 'r')
    module = ast.parse(f.read())
    module.body.append(cl)
    
    # Запись
    f = open(path, 'w')
    source_code = codegen.to_source(module)
    print source_code
    f.write(Parser.UNICODE_STR + source_code)
